name: TV Live Sources Updater

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  update-sources:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests beautifulsoup4 lxml
        
    - name: Create stable TV sources
      run: |
        cat > stable_tv_sources.py << 'EOF'
        import requests
        from datetime import datetime
        import concurrent.futures
        import time

        class StableTVUpdater:
            def __init__(self):
                self.session = requests.Session()
                self.session.headers.update({
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                })
                
                self.stable_sources = {
                    "CCTV1": [
                        "http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8",
                        "https://cctvcnch5c.v.wscdns.com/live/cctv1_2/playlist.m3u8",
                    ],
                    "CCTV2": [
                        "http://ivi.bupt.edu.cn/hls/cctv2hd.m3u8"
                    ],
                    "CCTV3": [
                        "http://ivi.bupt.edu.cn/hls/cctv3hd.m3u8"
                    ],
                    "CCTV4": [
                        "http://ivi.bupt.edu.cn/hls/cctv4hd.m3u8"
                    ],
                    "CCTV5": [
                        "http://ivi.bupt.edu.cn/hls/cctv5hd.m3u8"
                    ],
                    "CCTV5+": [
                        "http://ivi.bupt.edu.cn/hls/cctv5phd.m3u8"
                    ],
                    "CCTV6": [
                        "http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8"
                    ],
                    "CCTV7": [
                        "http://ivi.bupt.edu.cn/hls/cctv7hd.m3u8"
                    ],
                    "CCTV8": [
                        "http://ivi.bupt.edu.cn/hls/cctv8hd.m3u8"
                    ],
                    "CCTV9": [
                        "http://ivi.bupt.edu.cn/hls/cctv9hd.m3u8"
                    ],
                    "CCTV10": [
                        "http://ivi.bupt.edu.cn/hls/cctv10hd.m3u8"
                    ],
                    "CCTV11": [
                        "http://ivi.bupt.edu.cn/hls/cctv11hd.m3u8"
                    ],
                    "CCTV12": [
                        "http://ivi.bupt.edu.cn/hls/cctv12hd.m3u8"
                    ],
                    "CCTV13": [
                        "http://ivi.bupt.edu.cn/hls/cctv13hd.m3u8"
                    ],
                    "CCTV14": [
                        "http://ivi.bupt.edu.cn/hls/cctv14hd.m3u8"
                    ],
                    "CCTV15": [
                        "http://ivi.bupt.edu.cn/hls/cctv15hd.m3u8"
                    ],
                    "CCTV16": [
                        "http://ivi.bupt.edu.cn/hls/cctv16hd.m3u8"
                    ],
                    "CCTV17": [
                        "http://ivi.bupt.edu.cn/hls/cctv17hd.m3u8"
                    ],
                    "北京卫视": [
                        "http://ivi.bupt.edu.cn/hls/beijinghd.m3u8"
                    ],
                    "湖南卫视": [
                        "http://ivi.bupt.edu.cn/hls/hunanhd.m3u8"
                    ],
                    "浙江卫视": [
                        "http://ivi.bupt.edu.cn/hls/zhejianghd.m3u8"
                    ],
                    "江苏卫视": [
                        "http://ivi.bupt.edu.cn/hls/jiangsuhd.m3u8"
                    ],
                    "东方卫视": [
                        "http://ivi.bupt.edu.cn/hls/dongfanghd.m3u8"
                    ],
                    "安徽卫视": [
                        "http://ivi.bupt.edu.cn/hls/anhuihd.m3u8"
                    ],
                    "山东卫视": [
                        "http://ivi.bupt.edu.cn/hls/shandonghd.m3u8"
                    ],
                    "天津卫视": [
                        "http://ivi.bupt.edu.cn/hls/tianjinhd.m3u8"
                    ],
                    "深圳卫视": [
                        "http://ivi.bupt.edu.cn/hls/shenzhenhd.m3u8"
                    ],
                    "广东卫视": [
                        "http://ivi.bupt.edu.cn/hls/guangdonghd.m3u8"
                    ],
                    "凤凰中文": [
                        "http://liveali.ifeng.com/live/FHZW.m3u8"
                    ],
                    "凤凰资讯": [
                        "http://liveali.ifeng.com/live/FHZX.m3u8"
                    ],
                    "凤凰香港": [
                        "http://liveali.ifeng.com/live/FHGX.m3u8"
                    ]
                }

            def test_source(self, source_info):
                """测试直播源"""
                channel, source = source_info
                try:
                    start = time.time()
                    response = self.session.head(source, timeout=5, allow_redirects=True)
                    speed = time.time() - start
                    return channel, source, speed, response.status_code == 200
                except:
                    return channel, source, float('inf'), False

            def run(self):
                """运行测试并生成文件"""
                print("开始测试直播源...")
                
                # 准备测试任务
                test_tasks = []
                for channel, sources in self.stable_sources.items():
                    for source in sources:
                        test_tasks.append((channel, source))
                
                # 测试所有源
                valid_sources = {}
                with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                    futures = [executor.submit(self.test_source, task) for task in test_tasks]
                    
                    for future in concurrent.futures.as_completed(futures):
                        channel, source, speed, valid = future.result()
                        if valid and speed < 3:
                            if channel not in valid_sources:
                                valid_sources[channel] = []
                            valid_sources[channel].append((source, speed))
                            print(f"✓ {channel}: {source} ({speed:.2f}s)")
                
                # 按速度排序
                for channel in valid_sources:
                    valid_sources[channel].sort(key=lambda x: x[1])
                    valid_sources[channel] = [source for source, speed in valid_sources[channel]]
                
                # 生成文件
                self.generate_files(valid_sources)
                print(f"完成! 有效频道: {len(valid_sources)}")

            def generate_files(self, sources):
                """生成输出文件"""
                # 生成M3U文件
                m3u_content = """#EXTM3U
# Generated by Stable TV Source Updater
# Update Time: {}

""".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
                
                for channel, channel_sources in sources.items():
                    for i, source in enumerate(channel_sources):
                        m3u_content += '#EXTINF:-1 tvg-id="{}" tvg-name="{}" group-title="直播",{} 源{}\n'.format(
                            channel, channel, channel, i+1)
                        m3u_content += source + '\n'
                
                with open("tv_sources.m3u", "w", encoding="utf-8") as f:
                    f.write(m3u_content)
                
                # 生成TXT文件
                txt_content = "# 电视直播源更新于: {}\n".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
                txt_content += "# 格式: 频道名称,直播源URL\n\n"
                
                for channel, channel_sources in sources.items():
                    txt_content += "# {}\n".format(channel)
                    for source in channel_sources:
                        txt_content += source + '\n'
                    txt_content += "\n"
                
                with open("tv_sources.txt", "w", encoding="utf-8") as f:
                    f.write(txt_content)
                
                # 生成分类文件
                self.generate_categorized_files(sources)

            def generate_categorized_files(self, sources):
                """生成分类文件"""
                categories = {
                    "央视": [],
                    "卫视": [],
                    "凤凰": []
                }
                
                # 分类频道
                for channel, channel_sources in sources.items():
                    if channel.startswith('CCTV'):
                        categories["央视"].append((channel, channel_sources))
                    elif "卫视" in channel:
                        categories["卫视"].append((channel, channel_sources))
                    elif "凤凰" in channel:
                        categories["凤凰"].append((channel, channel_sources))
                
                # 为每个分类生成文件
                for category, channels in categories.items():
                    if channels:
                        # M3U文件
                        m3u_content = "#EXTM3U\n"
                        for channel, channel_sources in channels:
                            for i, source in enumerate(channel_sources):
                                m3u_content += '#EXTINF:-1 tvg-id="{}" tvg-name="{}" group-title="{}",{} 源{}\n'.format(
                                    channel, channel, category, channel, i+1)
                                m3u_content += source + '\n'
                        
                        with open("tv_sources_{}.m3u".format(category), "w", encoding="utf-8") as f:
                            f.write(m3u_content)
                        
                        # TXT文件
                        txt_content = "# {}直播源\n".format(category)
                        txt_content += "# 更新于: {}\n\n".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
                        for channel, channel_sources in channels:
                            txt_content += "# {}\n".format(channel)
                            for source in channel_sources:
                                txt_content += source + '\n'
                            txt_content += "\n"
                        
                        with open("tv_sources_{}.txt".format(category), "w", encoding="utf-8") as f:
                            f.write(txt_content)
                
                # 生成统计文件
                total_sources = sum(len(s) for s in sources.values())
                stats_content = """# 电视直播源统计
更新时间: {}

## 频道统计
- 总频道数: {}
- 总源数量: {}

## 各频道源数量
""".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), len(sources), total_sources)

                for channel, channel_sources in sorted(sources.items()):
                    stats_content += "- {}: {} 个源\n".format(channel, len(channel_sources))
                
                with open("STATS.md", "w", encoding="utf-8") as f:
                    f.write(stats_content)

        if __name__ == "__main__":
            updater = StableTVUpdater()
            updater.run()
        EOF
        
        python stable_tv_sources.py
        
    - name: Commit and push if changed
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add -A
        timestamp=$(date -u)
        git commit -m "Update TV sources: ${timestamp}" || exit 0
        git push